{
    "comic_number": 1755,
    "explanation": "{{comic\n| number    = 1755\n| date      = November 4, 2016\n| title     = Old Days\n| image     = old_days.png\n| titletext = Lot of drama in those days, including constant efforts to force the \"Reflections on Trusting Trust\" guy into retirement so we could stop being so paranoid about compilers.\n}}\n\n==Explanation==\nThis comic was followed 3 and a half years later by [[2324: Old Days 2]]. It shows a conversation between (young) [[Cueball]] and (old) [[Hairbun]] about computer programming in the past, specifically {{w|compilers}}. Cueball, having a faint idea of just how difficult and byzantine programming was \"in the old days\", asks Hairbun to enlighten him on the specifics. Hairbun promptly seizes the opportunity to screw with his head. While her initial agreement that code needed to be compiled for multiple architectures is correct, Hairbun's claims rapidly grow ridiculous.\n\nHairbun tells Cueball a tall tale about how hard it was back in the '''old days''', making it sound like some of the programming languages used today (C, C++) were written on punch cards and that you had to ship your code in the mail to a computer company ({{w|IBM}} in this case) to compile your code, which would take from four to six weeks. If there was a simple error, you would have to ship it again for another compilation. \n\nThis is, at best, a wild exaggeration, but is plausible to those who do not have the knowledge or context to challenge it, similar to a {{w|Snipe hunt}}, or several other cultural myths told about things like the {{w|Tooth Fairy}}. In some cases, decks of punched cards ''did'' have to be sent in to mainframe computers for processing, by people who didn't own their own machines. This wasn't generally the province of the computer ''manufacturers'', nor were the shipping times usually on the order of weeks, and professional programmers usually had better access to equipment. This can be contrasted with {{w|Kodak#The Kodak camera|Kodak's first mass-marketed cameras}}, in the 1890s. Owners were expected to send their cameras back to the Kodak company for technicians to take out the exposed film, develop it and print off copies, which would be sent back along with the reloaded camera, to simplify the process of film handling in the relatively new consumer market.\n\nIt is clear from Cueball's final ''Wow'' that he falls for it. Hairbun then continues to explain more and more implausible so-called facts from the olden days.\n\nWhat she says is true in that it was tough and slow to program on punch cards, which were actually used for an extended period of time. However, there is very little in the rest of Hairbun's story that is accurate, except that it was a big deal when the floppy disk was invented. The comment about punching holes in floppy disks is true. However, the nature and purpose of the holes punched this way was dramatically different than in punch cards. 5.25\" and 3.5\" floppy disks had holes or notches in them to indicate the data capacity and it was common to punch additional holes into cheaper, lower capacity floppy disks to trick the computer into writing more data on them than specified by the manufacturer. With punch cards, on the other hand, the holes themselves encoded the data so punching them was itself the act of programming. It is unclear if this was a coincidence, or intentionally included as a humorous aside to the readers who know the history as a misinterpreted truth in a sea of falsehoods.\n\nIn the title text, Hairbun continues her musings on the old compiler days, stating that there was ''a lot of drama in those days''. Specifically she references ''[http://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html Reflections on Trusting Trust]'' a famous 1984 paper by {{w|UNIX}} co-creator {{w|Ken Thompson}} in which he described a way to hide a virtually undetectable backdoor in the UNIX login code via a second backdoor in the C compiler. Using the technique in his paper, it would be impossible to discover the hacked login by examining the official source code for either the login or the compiler itself.  Ken Thompson may have actually included this backdoor in early versions of UNIX, undiscovered. Ken Thompson's paper demonstrated that it was functionally impossible to prove that any piece of software was fully trustworthy.  \n\nHairbun claims that one of the dramas she refers to was that people tried to force Ken Thompson to retire, so everyone could stop being so paranoid about compilers.  In reality, any coder who created the first version of a compiler (or a similar critical component) could inject a similar backdoor into software, so it would be false safety. Even if no one else had thought of this, Thompson's paper was there for any future hacker to see. However, the problem was (claimed to be) solved in {{w|David A. Wheeler}}'s Ph.D dissertation \"[http://dwheeler.com/trusting-trust/ Fully Countering Trusting Trust through Diverse Double-Compiling (DDC)]\".\n\n==Table of statements==\n{|class=\"wikitable\"\n!Statements\n!Concepts used\n!Explanation\n|-\n|Compile things for different processors\n|{{w|Compiler}}s convert code from a human-readable programming language into a binary code that can be directly executed by computer processors.\n|Many popular modern programming languages are either interpreted - meaning that they run directly from source code - or compile to an intermediate bytecode, like Java or common Python implementations. Programs written in such languages are portable across processor architectures - x86 to ARM, for example. {{w|Low-level programming language|Lower-level languages}} must take into account the features available on a given processor architecture and operating system. Before that, programs needed to compile directly into the native machine language for each processor they were intended to run on.\nNative {{w|Machine code|machine language}} is dependent on processor architecture. Therefore different processors designed around different architectures will not run the same compiled code (unless the architectures are compatible; AMD64 processors will run i386 code natively, for example.) If the same code needs to be run on multiple architectures, it must be compiled separately for each supported architecture.\n|-\n|To compile your code, you had to mail it to IBM. It took 4-6 weeks.\n|Similar to sending Kodachrome slide film to Kodak to be developed.\n|While IBM has released multiple compilers, they sent the compiler to you, you did not send the code to them. There is some kind of truth in the statement, though: when programming on mainframes, programmers submitted their source code in the evening for compilation overnight. When there was an error in the code, they did not get a compiled version of it back, and had to resubmit their code. Sometimes there were time slots available for compilation, and in universities, students would have to wait for their next time slot for another try.\n|-\n|Before garbage collection, data would pile up until the computer got full and you had to throw it away. \n|A {{w|Garbage collection (computer science)|garbage collector}} is a piece of the software that cleans the memory of data that is no longer being used in the execution of a program.\n|Garbage collection is a form of memory management that generally destroys objects or frees up memory once a program no longer needs it. In languages without automatic memory management, like C, the program itself must keep track of what memory has been allocated, and free it once it is no longer needed. If the program does not, it can end up trying to use more memory than the computer has, and may crash. This was, however, a ''temporary'' condition. In the worst case, a simple reboot will clear the computer's memory. \n|-\n|Early compilers could handle code fine, but comments had to be written in assembly.\n|A {{w|Comment (computer programming)|comment}} in programming is a text written in natural language that is meant to explain some feature of the source code; it is tagged such that the compiler will discard it to save space. {{w|Assembly language|Assembly}} is a low-level programming language.\n|Comments, in code, are portions of one or more lines that are ignored by the compiler. They are commonly used to explain or comment on the code itself. But sometimes the comments are written in a certain way to compile documentation automatically from it. Also, when examining the output of compilers it's a common practice to use assembly code annotated with comments containing the source code of the program from which the assembly code was generated.\n\nHairbun's comment is thus very strange, implying the compilers of the day could only distinguish between comments and code if assembly was used to insert the separating tags. \n|-\n|C could only be written on punch cards. You had to pick a compact font, or you'd only fit a few characters per card.\n|{{w|C (programming language)|C}} is a programming language. A {{w|punch card}} is a early form of storing data; the pattern of holes and non-holes in a paper or cardboard card represented information. \n|Punch cards were used through the late 1970s and early 1980s to enter programs and data in COBOL, FORTRAN and other early languages.  Punch cards and punch card machines were being replaced by magnetic storage and {{w|text editor|text editors}} by 1972, when C (or C++) was developed.  This site demonstrates a card punch and cards: [http://www.masswerk.at/keypunch/ Keypunch].\n\nHairbun implies that code was not written using keyboards, but by punching out letter and character shapes in the punch cards, and the computer would read keystrokes that way. Simply put, this was never true. Punch cards store characters in binary; there is no font involved and they store up to a fixed number of characters per card (80 characters in the most common format.)\n|-\n|C++ was big because it supported floppy disks. It still punched holes in them, but it was a start.\n|{{w|C++ (programming language)|C++}} is a programming language. A {{w|floppy disk}} is a form of storing data magnetically. It's way more advanced than punch cards (by several orders of magnitude; a card can store about 80 bytes, vs 1,474,560 bytes of a floppy disk), but it's still obsolete compared to modern storage.\n|Hairbun says that the improvement from C to C++ was that C++ finally \"supported floppy disks\", but then it turns out that in C++ the floppy disks were just used instead of punch cards. So the programming was to make holes in floppy disks rather than punch cards. This would of course not be an improvement as floppy disks store information magnetically, as opposed to physically, as punch cards do. This is likely a play on the concept of punching holes in 5.25\" floppy disks to double their storage (see {{w|Double-sided disk}}), or it can also be a reference to the \"index hole\" of 5.25\" floppy disks (see {{w|Floppy_disk#Design|Floppy disk Design}}  and the tiny hole at the right of the big central hole in this [https://www.staff.ncl.ac.uk/roger.broughton/museum/floppys/images/201041b.jpg image]). A notch in the side of 5.25\" floppy disks indicates when the disk could be written. Though many floppy disks were intended to have only a single side with data, many people used a hole punch to notch the opposite side of the disk, allowing a drive to write data to the other side of the disk in a single sided drive. 5.25\" floppies also featured a tiny \"index hole\" near the central hole of the disk.\n|}\n\n==Transcript==\n:[Cueball and Hairbun are standing together and Cueball is talking to her.]\n:Cueball: What were things like in the old days?\n:Cueball: I hear that you had to ... compile things for different processors?\n:Hairbun: Yeah\n\n:[Same setting in a slimmer panel, now Hairbun is replying.]\n:Hairbun: To compile your code, you had to mail it to IBM.\n:Hairbun: It took 4-6 weeks.\n\n:[Close-up of Hairbun from the waist up.]\n:Hairbun: Before garbage collection, data would pile up until the computer got full and you had to throw it away.\n\n:[Same setting as in the first panel with Hairbun gesturing toward Cueball raising one hand  palm up.]\n:Hairbun: Early compilers could handle code fine, but comments had to be written in assembly.\n\n:[In a frame-less panel Hairbun is seen from the front, with both arms out to the side with both hands held palm up.]\n:Hairbun: '''C''' could only be written on punch cards.You had to pick a compact font, or you'd only fit a few characters per card.\n\n:[Exactly the same setting as the first panel, but with Hairbun doing the talking.]\n:Hairbun: '''C++''' was big because it supported floppy disks.\n:Hairbun: It still punched holes in them, but it was a start.\n:Cueball: Wow.\n\n{{comic discussion}}\n\n[[Category:Comics featuring Cueball]]\n[[Category:Comics featuring Hairbun]]\n[[Category:Comics sharing name|Old Days]]\n[[Category:Programming]]\n[[Category:Old Days]]"
}