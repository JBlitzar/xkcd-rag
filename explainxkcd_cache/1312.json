{
    "comic_number": 1312,
    "explanation": "{{comic\n| number    = 1312\n| date      = January 3, 2014\n| title     = Haskell\n| image     = haskell.png\n| titletext = The problem with Haskell is that it's a language built on lazy evaluation and nobody's actually called for it.\n}}\n\n==Explanation==\nThe comic pokes fun at {{w|Haskell (programming language)|Haskell}}, a {{w|Functional programming|functional programming language}}. Functional programming languages are based on the mathematical concept of a function, that is two calls to a function always produce the same results given the same inputs. {{w|Side effect (computer science)|Side effect}}s of a function call are changes to the program state or observable interactions with the outside world, other than returning a value. As a simple example, if a <code>sum</code> function changes a global variable, or prints the sum before returning it, those are side effects. Functions in most other languages frequently have side effects, typically making them hard to analyze. Functional programming languages seek to avoid side effects when possible. ''Pure'' functional programming languages like Haskell push this agenda by isolating the inevitable side-effects (input/output at least) through the type system (more specifically in {{w|monad (functional programming)|monads}} for Haskell).\n\nThe first joke says that Haskell only has no side effects because no one ever uses Haskell programs. Even in a traditional procedural programming language like {{w|C (programming language)|C}}, if the program does not run, it can't have side effects.\n\nIn Haskell, effects are first class values. This means that you can use effects just like any value, assign them to a variable, pass them around, or manipulate them to make new and different effects. Thus, there are technically no side effects, only primary effects.\n\nThe title text is a joke about Haskell's {{w|lazy evaluation}}. The basic concept is that a value is not computed until it is actually used. Thus, it is possible to have a name representing the entire infinite list of {{w|Fibonacci number|Fibonacci numbers}}. However, until a particular element of the list is accessed, no work is actually done. The joke plays on \"called\" (referring to calling a function) vs. \"called for\" (requesting). Thus, Haskell may have value, but no one has either invoked it to get that value or requested such a language. A simpler example may be:\n\n <nowiki>or :: Bool -> Bool -> Bool\nor True _ = True\nor _ b = b\n\nor (2 + 2 == 4) (even (fibonacci 10000))</nowiki>\nThe \"or\" function is defined as a normal function but can conclude instantly without computing the 10000th Fibonacci number (a daunting task) since this second parameter isn't necessary : \"true or whatever\" is always true.\n\nIn reality, Haskell is indeed actively used, though it is not one of the most popular languages. It is in particular used by some financial institutions, safety conscious start-ups and websites (there are several active web frameworks in Haskell) like [[Randall]]'s [http://www.reddit.com/r/haskell/comments/uved7/waldo_the_haskell_powered_codebase_behind_xkcds/ own].\n\n==Transcript==\n:[Megan and Cueball are discussing.]\n:Megan: Code written in Haskell is guaranteed to have no side effects.\n:Cueball: ...because no one will ever run it?\n{{comic discussion}}\n[[Category:Comics featuring Cueball]]\n[[Category:Comics featuring Megan]]\n[[Category:Programming]]"
}