{
    "comic_number": 303,
    "explanation": "{{comic\n| number    = 303\n| date      = August 15, 2007\n| title     = Compiling\n| image     = compiling.png \n| titletext = 'Are you stealing those LCDs?' 'Yeah, but I'm doing it while my code compiles.'\n}}\n\n==Explanation==\nComputer programming involves writing instructions for a computer to follow, in a specific {{w|programming language}}, which is largely human readable and writable, at least to programmers who understand that language. However, for the computers to follow instructions, they need to be given {{w|machine code}} — the actual \"language\" that computers \"speak\" and one that ''can'' be written directly with the correct tools, but would be too tedious and error-prone for just about any practical modern project where alternatives exist, where anything more than a {{w|\"Hello, World!\" program|Hello World}} could be awkward to implement straight into machine-code.\n\nConversion from the more conveniently human-writable code into computer-{{w|executable}} files is performed by {{w|Assembly language#Assembler|assemblers}}, {{w|Interpreter (computing)|interpreters}}, or {{w|compilers}}.\n\nPrograms can be written in {{w|Assembly language|assembly code}}, which is basically just a set of mnemonics that make machine code much easier for a human to remember and correctly parse; the human-written assembly code is then run through a simple assembler to convert it directly into machine code. Assembly coding is necessary whenever one is programming for a completely new architecture (one for which no other tools yet exist), and is still used in some other situations (as it allows the code to be optimized more closely for the system on which it is to run than is possible with other types of coding), but is still fairly tedious and error-prone, and assembly code needs to be completely rewritten if one wants to port it to a computer with a different architecture.\n\nAn interpreter (e.g. that for {{w|PHP}} for one example) generally reads through the code, or script, each line at a time as and when required, and has to do a lot of work with various processing overheads and the risk of hitting an invalid instruction or mistake in syntax that it can't handle. It also requires that a relevant version of the interpreter exist on any machine that has to run the script and perhaps some additional knowledge by the end-user.\n\nFor widely distributed (and especially commercial) programs, some form of compilation will instead be used. Compiling may have just one computer system read through the human-written code and (barring errors) produces the equivalent stand-alone and direct machine-readable code, suitable for a given range of computers. This process might involve several passes to check for 'obvious' errors in the code, as well as converting some programming concepts that are easiest for humans to understand into equivalent concepts that may be far easier for the computer to work with.\n\nAs such, compiling takes a certain amount of time at the time of production. Normally, this takes a few seconds, but, depending on the size of the project and the power of the computer doing the compilation, the time required to compile a program may measure in minutes, or even hours. As of 2015, the {{w|Linux Kernel}} contains over 19 million lines of code, arguably a massive job for any compiler, but if done correctly, it saves time for all the people who will ultimately be using its output.\n\nThus, when Cueball is caught wasting time at work, he argues that such activities are not worse than any other possible ones, at this moment. If his job is writing code and compiling it, then there may be nothing else that he ''can'' do right now. He cannot usefully tweak the code before it finishes compiling and the expected result checked.\n\nThe title text takes this a step further. Cueball claims that ''all'' activities are equally benign while the code is compiling — and that includes committing illegal acts, such as stealing {{w|Liquid-crystal display|LCDs}}.\n\nNine years after this comic was released, [[Randall]] made a comic called [[1755: Old Days]] about how compiling worked in the old days. It was Cueball who asked. The next comic after that, [[1756: I'm With Her]], was released the Monday before the {{w|2016 United States presidential election}}. And in that comic, a Cueball with a sword on an office chair like in this comic is featured. It seems realistic that Randall had that politically loaded comic ready for some time, and when finding and deciding to use this old version of Cueball, he may have been inspired by the compiling theme to make Old Days.\n\nNearly seventeen years after, it seems that the Quality Assurance department had possibly appropriated a whole day of 'enforced downtime' for [[2928: Software Testing Day]]. Assuming that the arranged testing goes as planned.\n\nSoon after, many computer users had another day off due to a glitch in [[CrowdStrike]] that causes early-boot BSODs.\n\n==Transcript==\n:The #1 Programmer Excuse for Legitimately Slacking Off: \"My code's compiling.\"\n:[Two programmers are sword-fighting on office chairs in a hallway. An unseen manager calls them back to work through an open office door.]\n:Manager: Hey! Get back to work!\n:Cueball: Compiling!\n:Manager: Oh. Carry on.\n\n==Trivia==\nThis comic used to be [https://web.archive.org/web/20211215135852/https://store.xkcd.com/products/compiling available as a T-shirt] and [https://web.archive.org/web/20220125023401/https://store.xkcd.com/products/signed-prints as a signed print] in the xkcd store before it was [[Store|shut down]].\n\n{{comic discussion}}\n[[Category:Comics featuring Cueball]]\n[[Category:Programming]]\n[[Category:Comics with xkcd store products]]"
}